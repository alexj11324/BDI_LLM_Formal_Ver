"""
1. Parse grounded domain
2. generate a plan
3. take subset of actions
4.
"""
from model_parser.parser_new import parse_model
from model_parser.writer_new import ModelWriter
from model_parser.constants import *
import os
import subprocess
import random
import re
from copy import deepcopy



class Executor:
    def __init__(self, domain, problem, ground=True, seed=10):
        self.is_pr_grounded = ground
        if ground:
            self.model = parse_model(domain, problem)
        else:
            pr_domain, pr_problem = self.ground_domain(domain, problem)
            self.model = parse_model(pr_domain, pr_problem)

        self.is_upper = True
        self.is_capitalized = False

        # Check if actions are upper case or capitalized
        with open(domain) as f:
            file_content = f.read()
            match = re.search(r"\(\:\s*(action)", file_content, re.IGNORECASE)
            if match:
                keyword = match.group(1)
                self.is_upper = keyword.isupper()
                self.is_capitalized = keyword.istitle()
            else:
                self.is_upper = True

        self.plan, cost = self.get_plan(domain, problem, grounded=ground)
        self.prefix = random.randint(1, len(self.plan)) if self.plan else 0
        # self.prefix = 1

        self.init_state = self.get_sets(self.model[INSTANCE][INIT][PREDICATES])
        self.goal_state = self.get_sets(self.model[INSTANCE][GOAL])
        self.new_goal_state = deepcopy(self.init_state)
        # self.new_goal_state = self.new_goal_state.union(self.goal_state)
        self.replanning_init = deepcopy(self.goal_state)
        # self.replanning_init = self.replanning_init.union(self.init_state)


        # self.final_state = self.get_final_state(self.init_state, self.plan)
        self.final_state = self.get_final_state(self.init_state, self.plan[0:self.prefix])
        # self.all_preds = self.get_sets(self.model[PREDICATES])
        # self.not_true_preds = self.all_preds.difference(self.final_state)
        # for i in self.final_state:
        #     self.final_state_dict[i] = "Yes"
        # for i in self.not_true_preds:
        #     self.final_state_dict[i] = "No"

    def get_final_state(self, curr_state, plan):
        # THis assumes plan is generated by a sound planner
        initial_state = curr_state
        if self.is_pr_grounded:
            for act in plan:
                act = act.upper()
                act_adds = self.get_sets(self.model[DOMAIN][act][ADDS])
                act_dels = self.get_sets(self.model[DOMAIN][act][DELS])
                initial_state = initial_state.union(act_adds)
                initial_state = initial_state.difference(act_dels)
        else:
            for act in plan:
                act = act.upper() if self.is_upper else act
                act = act.capitalize() if self.is_capitalized else act
                try:
                    preconds, act_adds, act_dels = self.ground_strips_action(act)
                except Exception as e:
                    print("Exception", e)
                    raise Exception
                # act_adds = self.get_sets(self.model[DOMAIN][act][ADDS])
                # act_dels = self.get_sets(self.model[DOMAIN][act][DELS])
                initial_state = initial_state.union(act_adds)
                initial_state = initial_state.difference(act_dels)

        return initial_state


    def ground_strips_action(self, act):
        """
        'LOAD-TRUCK': {'params': [('obj', 'object'), ('truck', 'object'), ('loc', 'object')], 'pos_prec': [['obj', ['?obj']], ['truck', ['?truck']], ['location', ['?loc']], ['at', ['?truck', '?loc']], ['at', ['?obj', '?loc']]], 'adds': [['in', ['?obj', '?truck']]], 'dels': [['at', ['?obj', '?loc']]], 'functional': [], 'conditional_adds': [], 'cost': None
        """
        
        act_name = act.split("_")[0]
        act_name = act_name.upper() if self.is_upper else act_name
        act_name = act_name.capitalize() if self.is_capitalized else act_name
        act_params = act.split("_")[1:]
        act_details = self.model[DOMAIN][act_name]
        if len(act_params) != len(act_details['params']):
            print("ERROR: Wrong number of parameters for action:", act_name)
            print(act_details)
            return None, None, None
        #Create act-params dict
        act_params = dict([('?'+i[0], act_params[ind]) for ind, i in enumerate(act_details['params'])])

        def get_pred(pred):
            if len(pred[1]):
                return '_'.join([pred[0]] + [act_params[j] for j in pred[1]]).lower()
            else:
                return pred[0].lower()

        # Create preconditions
        preconds = [get_pred(i) for i in act_details['pos_prec']]
        # Create adds
        adds = [get_pred(i) for i in act_details['adds']]
        # Create dels
        dels = [get_pred(i) for i in act_details['dels']]
        return preconds, adds, dels

    def get_action_preconditions(self, act):
        if not self.is_pr_grounded:
            preconds, _, _ = self.ground_strips_action(act)
            return set(preconds)
        return self.get_sets(self.model[DOMAIN][act][POS_PREC])

    def get_relaxed_final_state(self, curr_state, plan=None, precond_relax=False, del_relax=True):
        initial_state = curr_state
        if plan is None:
            plan = self.plan
        executable = True
        for act in plan:
            act = act.upper()
            
            # Check preconditions
            if act not in self.model[DOMAIN]:
                just_act_name = act.split('_')[0]
                # print(just_act_name, [i for i in self.model[DOMAIN]])
                
                if not any([just_act_name in i for i in self.model[DOMAIN]]):
                    print("WARNING: Action {} not found in domain".format(act))
                    print(self.model[DOMAIN].keys())
                    executable = False
                    break
            if self.is_pr_grounded:
                act_pos_precs = self.get_sets(self.model[DOMAIN][act][POS_PREC])
                act_adds = self.get_sets(self.model[DOMAIN][act][ADDS])
                act_dels = self.get_sets(self.model[DOMAIN][act][DELS])
            else:
                act_pos_precs, act_adds, act_dels = self.ground_strips_action(act)
                if act_pos_precs is None:
                    executable = False
                    print("ERROR: Action {} not found in domain".format(act))
                    break
                act_pos_precs, act_adds, act_dels = set(act_pos_precs), set(act_adds), set(act_dels)
            if not precond_relax:
                if not act_pos_precs.issubset(initial_state):
                    executable = False
                    print("WARNING: Action {} not executable".format(act))
                    print("Preconditions not satisfied", act_pos_precs.difference(initial_state))
                    print(initial_state)
                    break
            
            initial_state = initial_state.union(act_adds)
            if not del_relax:
                initial_state = initial_state.difference(act_dels)

    def get_plan(self, domain, problem, grounded=True):
        """
        Executes FD and returns a random prefix of the plan
        :param domain:
        :param problem:
        :return:
        """
        fd_path = os.getenv("FAST_DOWNWARD")
        if not fd_path:
            raise ValueError("FAST_DOWNWARD environment variable not set")

        fd_script = os.path.join(fd_path, "fast-downward.py")
        try:
            subprocess.run(
                [fd_script, domain, problem, "--search", "astar(lmcut())"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.STDOUT,
                check=True,
            )
        except subprocess.CalledProcessError:
            pass
        # USE SAS PLAN to get actions
        plan = []
        cost = 0
        try:
            with open('sas_plan') as f:
                for line in f:
                    if ';' not in line:
                        plan.append((line.strip()[1:-1].strip()))
                    else:
                        cost_group = re.search(r'\d+', line)
                        if cost_group:
                            cost = int(cost_group.group())
            if cost == 0:
                cost = len(plan)
        except FileNotFoundError:
            return 'No plan found', 0
        # os.remove('sas_plan')
        if grounded:
            new_plan = ['_'.join(i.split(' ')) for i in plan]
            return new_plan, cost

        return plan, cost

    def get_sets(self, list_of_preds):
        if self.is_pr_grounded:
            return set([i[0] for i in list_of_preds])  
        else: 
            sets = []
            for i in list_of_preds:
                if len(i[1]):
                    sets.append('_'.join([i[0],'_'.join(i[1])]))
                else:
                    sets.append(i[0])
            return set(sets)

    def ground_domain(self, domain, problem):
        pr2_path = os.getenv("PR2")
        if not pr2_path:
            raise ValueError("PR2 environment variable not set")

        pr2_bin = os.path.join(pr2_path, "pr2plan")
        try:
            subprocess.run(
                [pr2_bin, "-d", domain, "-i", problem, "-o", "blank_obs.dat"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.STDOUT,
                check=True,
            )
        except subprocess.CalledProcessError:
            pass
        pr_domain = 'pr-domain.pddl'
        pr_problem = 'pr-problem.pddl'
        self.remove_explain(pr_domain, pr_problem)
        return pr_domain, pr_problem

    def remove_explain(self, domain, problem):
        try:
            for file_path in [problem, domain]:
                with open(file_path, "r") as handle:
                    lines = handle.readlines()
                with open(file_path, "w") as handle:
                    for line in lines:
                        if "EXPLAIN" not in line:
                            handle.write(line)
        except FileNotFoundError:
            raise Exception('[ERROR] Removing "EXPLAIN" from pr-domain and pr-problem files.')

    def get_new_instance(self, change_goal, change_init):
        
        if change_goal:
            goal = []
            if self.is_pr_grounded:
                for i in self.new_goal_state:
                    goal.append([i, []])
            else:
                for i in self.new_goal_state:
                    pred = i.split('_')
                    if len(pred) > 1:
                        goal.append([pred[0], pred[1:]])
                    else:
                        goal.append([pred[0], []])
            new_model = deepcopy(self.model)
            new_model[INSTANCE][GOAL] = goal
            writer = ModelWriter(new_model)
            writer.write_files('pr-new-domain.pddl', 'pr-new-problem.pddl')
            return new_model
        if change_init:
            # print(self.init_state, self.replanning_init)
            init = []
            if self.is_pr_grounded:
                for i in self.replanning_init:
                    init.append([i, []])
            else:
                for i in self.replanning_init:
                    pred = i.split('_')
                    if len(pred) > 1:
                        init.append([pred[0], pred[1:]])
                    else:
                        init.append([pred[0], []])
            new_model = deepcopy(self.model)
            # print(new_model[INSTANCE][INIT][PREDICATES], init)
            new_model[INSTANCE][INIT][PREDICATES] = init
            writer = ModelWriter(new_model)
            writer.write_files('pr-new-domain.pddl', 'pr-new-problem.pddl')
            return new_model



if __name__ == "__main__":
    domain = 'instances/ipc_domain.pddl'
    problem = 'instances/instance-2.pddl'
    exec = executor(domain, problem)
    print("\n")
    exec.replanning(0)
    print("PLAN: ", exec.plan)
    print("INITIAL STATE: ", exec.init_state)
    print("After Plan Execution (A.P.E.) STATE: ", exec.final_state)
    print("GOAL STATE: ", exec.goal_state)
    print("NOT TRUE PREDS: ", exec.not_true_preds)
    exec.get_new_instance(False, True)
    print(exec.get_plan('pr-new-domain.pddl', 'pr-new-problem.pddl'))
